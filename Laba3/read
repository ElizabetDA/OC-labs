В рамках лабораторной работы №3 были использованы следующие ключевые аспекты, соответствующие целям работы: взаимодействие между процессами с использованием
отображаемых файлов (memory-mapped files) и управление процессами с помощью сигналов. Рассмотрим эти темы подробнее, включая теорию и реализацию.
Основные темы лабораторной работы
1. Файловые системы
Что это?

Файловая система — это способ организации данных на физическом или виртуальном носителе. Она предоставляет интерфейс для хранения,
чтения и изменения данных, обычно через файловые дескрипторы или пути.
Использование в коде:

    Открытие файла (open).
    Установка размера файла (ftruncate).
    Закрытие файла (close).

Пример:

В коде мы создали файл для обмена данными между процессами:

int fd = open("shared_memory_file", O_CREAT | O_RDWR, 0644);
if (fd == -1) {
    perror("Failed to open file");
    exit(EXIT_FAILURE);
}
if (ftruncate(fd, FILE_SIZE) == -1) {
    perror("Failed to set file size");
    close(fd);
    exit(EXIT_FAILURE);
}

    O_CREAT | O_RDWR — создаёт файл, если он не существует, и открывает его для чтения и записи.
    ftruncate — изменяет размер файла на заданное количество байтов.

2. Отображаемые файлы (Memory-Mapped Files)
Что это?

Memory-mapped files — технология, которая позволяет отобразить содержимое файла в виртуальную память процесса. Это даёт возможность работать
с файлом как с обычным массивом в памяти, избегая системных вызовов для чтения/записи данных.
Почему это эффективно?

    Прямое отображение файла в память позволяет обойти избыточные операции ввода-вывода.
    Это стандартный способ обмена данными между процессами, работающими на одном хосте.

Использование в коде:

Файл отображается в память с помощью вызова mmap:

char *mapped_memory = mmap(NULL, FILE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
if (mapped_memory == MAP_FAILED) {
    perror("Failed to mmap file");
    close(fd);
    exit(EXIT_FAILURE);
}

    mmap:
        NULL: ядро выбирает начальный адрес отображения.
        FILE_SIZE: размер отображаемой области.
        PROT_READ | PROT_WRITE: разрешение на чтение и запись.
        MAP_SHARED: изменения в памяти отразятся в файле.
        fd: файловый дескриптор.

    Деинициализация: Когда файл больше не нужен, отображение снимается:

    munmap(mapped_memory, FILE_SIZE);

3. Межпроцессное взаимодействие
Что это?

Межпроцессное взаимодействие (IPC, Inter-Process Communication) — это обмен данными между процессами. Одним из способов IPC является использование memory-mapped files.
Как это реализовано:

    Родительский процесс записывает данные в отображаемую память.
    Родитель посылает сигнал дочернему процессу (SIGUSR1), чтобы уведомить его о готовности данных.
    Дочерний процесс читает данные, обрабатывает их и записывает результат обратно.

4. Сигналы
Что это?

Сигнал — это асинхронное уведомление, посылаемое процессу или группе процессов для уведомления о событии (например, завершении работы).
Использование в коде:

    Посылка сигнала: Родитель уведомляет дочерний процесс:

kill(pid, SIGUSR1);

Обработка сигнала: Дочерний процесс обрабатывает сигнал с помощью обработчика:

    void handle_signal(int signo) {
        if (signo == SIGUSR1) {
            parent_signaled = 1;
        }
    }
    struct sigaction sa;
    sa.sa_handler = handle_signal;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGUSR1, &sa, NULL);

5. Работа с процессами
Что это?

Процессы в операционных системах создаются с помощью вызова fork. Это порождает новый процесс (дочерний), который является копией родительского процесса.
Использование:

    Создание дочернего процесса:

pid_t pid = fork();
if (pid == -1) {
    perror("Failed to fork");
    exit(EXIT_FAILURE);
}
if (pid == 0) {
    // Код дочернего процесса
}

Ожидание завершения дочернего процесса: Родитель ожидает завершения дочернего процесса с помощью wait:

    wait(NULL);

6. Обработка ошибок
Почему это важно?

При работе с системными вызовами (например, fork, open, mmap) важно проверять результаты, так как ошибки могут нарушить работу программы.
Использование:

    Проверка на ошибки после каждого системного вызова:

    if (fd == -1) {
        perror("Failed to open file");
        exit(EXIT_FAILURE);
    }

    Использование perror для вывода детальной информации об ошибке.

Связь с целями лабораторной работы

    Освоение принципов работы с файловыми системами:
        Использование системных вызовов open, ftruncate, close.
        Работа с отображаемыми файлами.

    Обеспечение обмена данных между процессами посредством технологии «File mapping»:
        Прямое взаимодействие между родительским и дочерним процессами через mmap.

    Обработка системных ошибок:
        Проверка всех системных вызовов.
        Использование сигналов для синхронизации.

Итог

Программа демонстрирует:

    Как использовать отображаемые файлы для обмена данными между процессами.
    Как применять сигналы для синхронизации процессов.
    Основы работы с файловой системой (создание, открытие и изменение файлов).
    Обеспечение безопасности через обработку ошибок.

1. Отображаемые файлы (Memory-Mapped Files)
Что это?

Отображаемые файлы (mmap) — это механизм, позволяющий связать содержимое файла с виртуальной памятью процесса.
После отображения мы можем читать и записывать данные в файл через память, как если бы это был обычный массив.
Зачем это нужно?

    Быстродействие: Обход системных вызовов чтения (read) и записи (write).
    Универсальность: Один и тот же файл может быть отображён в память нескольких процессов, что позволяет использовать его как инструмент для обмена данными.
    Экономия памяти: Благодаря механизмам копирования при записи (copy-on-write) изменения отражаются только на изменённых страницах памяти.

Важные функции и параметры mmap
Основная функция:

void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

    addr: Указывает адрес, по которому нужно отобразить файл. Обычно передаётся NULL, чтобы система выбрала адрес автоматически.
    length: Размер области отображения.
    prot: Указывает тип доступа:
        PROT_READ: Доступ на чтение.
        PROT_WRITE: Доступ на запись.
    flags:
        MAP_SHARED: Изменения видны другим процессам, отображающим тот же файл.
        MAP_PRIVATE: Изменения видны только текущему процессу.
    fd: Файловый дескриптор.
    offset: Смещение в файле для отображения.

Удаление отображения:

int munmap(void *addr, size_t length);

    Освобождает память, выделенную mmap.

Пример в программе:

В коде родительский процесс отображает файл:

char *mapped_memory = mmap(NULL, FILE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
if (mapped_memory == MAP_FAILED) {
    perror("Failed to mmap file");
    close(fd);
    exit(EXIT_FAILURE);
}

    PROT_READ | PROT_WRITE: Даёт возможность как читать, так и записывать в память.
    MAP_SHARED: Изменения в памяти видны другим процессам, использующим тот же файл.

Как mmap используется для обмена данными?

    Родительский процесс записывает данные в отображаемую память:

strncpy(mapped_memory, input, FILE_SIZE - 1);

Дочерний процесс считывает данные из той же области памяти:

    remove_vowels(mapped_memory, result);
    strncpy(mapped_memory, result, FILE_SIZE - 1);

    Все изменения в памяти автоматически отражаются в файле.

2. Сигналы
Что это?

Сигналы — это асинхронный механизм взаимодействия процессов. Сигнал посылается одному или нескольким процессам для уведомления об определённом событии.
Основные сигналы

    SIGUSR1 и SIGUSR2: Пользовательские сигналы, которые можно использовать для синхронизации.
    SIGTERM: Сигнал для завершения процесса.
    SIGKILL: Принудительное завершение процесса (не обрабатывается).
    SIGCHLD: Посылается родительскому процессу при завершении дочернего.

Использование сигналов в программе

В программе сигналы используются для синхронизации между родительским и дочерним процессами.
Отправка сигнала

Родительский процесс уведомляет дочерний о доступности новых данных:

kill(pid, SIGUSR1);

Обработка сигнала

Дочерний процесс обрабатывает сигнал, используя sigaction:

void handle_signal(int signo) {
    if (signo == SIGUSR1) {
        parent_signaled = 1;
    }
}

Настройка обработчика сигнала:

struct sigaction sa;
sa.sa_handler = handle_signal;
sigemptyset(&sa.sa_mask);
sa.sa_flags = 0;
sigaction(SIGUSR1, &sa, NULL);

Поток обработки

    Родитель пишет данные в отображаемую память.
    Родитель отправляет сигнал дочернему процессу (SIGUSR1).
    Дочерний процесс обрабатывает данные.
    Дочерний процесс уведомляет родителя, посылая сигнал обратно.

3. Процессы
Как создаются процессы?

В коде использован вызов fork для создания дочернего процесса:

pid_t pid = fork();
if (pid == -1) {
    perror("Failed to fork");
    exit(EXIT_FAILURE);
}
if (pid == 0) {
    // Код дочернего процесса
}

    fork: Копирует текущий процесс, создавая новый.
    Результат:
        pid > 0: Код выполняется в родительском процессе.
        pid == 0: Код выполняется в дочернем процессе.
        pid == -1: Ошибка при создании процесса.

Как управлять процессами?

    Ожидание завершения дочернего процесса:

wait(NULL);

Завершение процесса:

exit(EXIT_SUCCESS);

Посылка сигналов для управления:

    kill(pid, SIGTERM);

4. Обработка ошибок
Зачем это нужно?

Ошибки могут возникать при работе с системными вызовами (open, fork, mmap, и т.д.). Игнорирование ошибок может привести к некорректной работе программы.
Основные методы обработки

    Проверка возвращаемого значения: После каждого системного вызова проверяется результат:

int fd = open("file", O_CREAT | O_RDWR, 0644);
if (fd == -1) {
    perror("Failed to open file");
    exit(EXIT_FAILURE);
}

Вывод сообщений об ошибках: Используется perror для вывода детальной информации:

perror("Error description");

Аварийное завершение программы: При критических ошибках программа завершается:

    exit(EXIT_FAILURE);

Преимущества выбранного подхода

    Эффективность: Использование mmap снижает накладные расходы на чтение и запись данных.

    Простота синхронизации: Сигналы позволяют избежать сложных механизмов блокировок.

    Надёжность: Обработка системных ошибок обеспечивает стабильность программы.

1. Вопросы по работе с файловыми системами
Основные вопросы:

    Как работает open? Какие флаги используются?
        Ответ: Функция open открывает файл для чтения/записи. Основные флаги:
            O_CREAT: создаёт файл, если он не существует.
            O_RDWR: открывает файл для чтения и записи.
            O_TRUNC: обрезает файл до длины 0.
            O_APPEND: запись данных в конец файла.

    Для чего используется ftruncate?
        Ответ: ftruncate изменяет размер файла. В нашем коде это нужно, чтобы создать файл нужного размера для отображения в память.

    Как mmap связана с файловой системой?
        Ответ: mmap отображает содержимое файла в виртуальную память. Все изменения в памяти синхронно записываются в файл, если используется флаг MAP_SHARED.

2. Вопросы по отображаемым файлам (mmap)
Основные вопросы:

    Как работает mmap?
        Ответ: mmap отображает файл в адресное пространство процесса. Это позволяет работать с файлом как с массивом в памяти, ускоряя доступ к данным.

    Какие преимущества у mmap перед read и write?
        Ответ:
            Быстрее, так как данные читаются напрямую из памяти без дополнительных вызовов.
            Удобнее, так как файл становится доступным как массив.
            Можно использовать для межпроцессного взаимодействия.

    Что делает munmap?
        Ответ: munmap освобождает область памяти, выделенную через mmap.

    Что произойдёт, если файл отображён в память как MAP_SHARED, но один из процессов завершился?
        Ответ: Отображение файла продолжит существовать, пока другой процесс работает или пока его не снимут через munmap.

3. Вопросы по сигналам
Основные вопросы:

    Какие сигналы используются в программе?
        Ответ: В программе используются SIGUSR1 для уведомления процессов о готовности данных и SIGTERM для завершения дочернего процесса.

    Как работает обработчик сигнала (sigaction)?
        Ответ:
            sigaction позволяет установить функцию-обработчик для сигнала.
            При получении сигнала указанная функция автоматически вызывается.

    Почему вы выбрали SIGUSR1, а не, например, SIGKILL?
        Ответ: SIGUSR1 — это пользовательский сигнал, который можно использовать для произвольных задач. SIGKILL завершает процесс принудительно и не обрабатывается.

4. Вопросы по работе с процессами
Основные вопросы:

    Что такое fork и как он работает?
        Ответ: fork создаёт копию текущего процесса. После вызова:
            Родительский процесс получает PID дочернего процесса.
            Дочерний процесс получает 0 как результат вызова.

    Как родительский процесс ожидает завершения дочернего?
        Ответ: С помощью функции wait:

        wait(NULL);

    Что такое копирование при записи (copy-on-write) в контексте fork?
        Ответ: При вызове fork память родительского процесса не копируется сразу. Копирование происходит только при изменении данных в одном из процессов.

5. Вопросы по синхронизации и IPC
Основные вопросы:

    Почему вы используете сигналы для синхронизации, а не семафоры?
        Ответ: Сигналы проще использовать для простого уведомления процесса о готовности данных. Семафоры полезны, если требуется сложная синхронизация.

    Какие ещё существуют способы межпроцессного взаимодействия (IPC)?
        Ответ: Основные способы:
            Файлы — процессы читают и пишут в один и тот же файл.
            Каналы (pipe) — позволяют передавать данные между процессами.
            Сокеты — используются для обмена данными, в том числе между разными машинами.
            Семафоры и очереди сообщений — для сложной синхронизации.

6. Вопросы по обработке ошибок
Основные вопросы:

    Какие ошибки могут возникнуть при использовании mmap?
        Ответ:
            Файл не существует (ENOENT).
            Недостаточно прав доступа (EACCES).
            Размер файла меньше запрашиваемой области отображения.

    Что произойдёт, если процесс забудет вызвать munmap?
        Ответ: Вся память, выделенная через mmap, будет освобождена системой после завершения процесса. Однако это может привести к утечкам памяти в долгоживущих процессах.

    Что делать, если fork возвращает -1?
        Ответ: Это означает, что система не смогла создать новый процесс (например, из-за превышения лимита процессов). В таком случае программа должна вывести ошибку и завершиться:

        if (pid == -1) {
            perror("Failed to fork");
            exit(EXIT_FAILURE);
        }

7. Вопросы по системе в целом
Основные вопросы:

    Чем отличается процесс от потока?
        Ответ:
            Процесс: Имеет собственное адресное пространство. Общение между процессами требует механизмов IPC.
            Поток: Разделяет память с другими потоками в процессе. Общение между потоками проще, но требует синхронизации (например, через мьютексы).

    Какие существуют ограничения на использование fork?
        Ответ:
            Ограничение на максимальное количество процессов пользователя.
            Высокая нагрузка на память из-за копирования данных.

    Что такое файловый дескриптор?
        Ответ: Это уникальный идентификатор, используемый для работы с открытыми файлами.
        Например, файл, отображённый в память, сначала открывается через open, который возвращает дескриптор.

Советы для успешной защиты

    Понимание кода:
        Объясните, как работает каждая часть программы.
        Будьте готовы ответить, почему вы выбрали именно эту реализацию (например, почему используете mmap вместо других методов IPC).

    Практические сценарии:
        Подготовьтесь объяснить, как программу можно адаптировать для других задач.
        Например, как использовать mmap для обмена бинарными данными между процессами.

    Системные вопросы:
        Знание базовых концепций операционных систем, таких как процессы, потоки, память, и IPC, — ключевой аспект защиты.

память по страничкам ?????????????????????
